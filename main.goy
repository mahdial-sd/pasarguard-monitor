package main

import (
    "bufio"
    "bytes"
    "crypto/tls"
    "encoding/json"
    "fmt"
    "io/ioutil"
    "log"
    "net/http"
    "regexp"
    "strings"
    "sync"
    "time"

    tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
    "gopkg.in/yaml.v3"
)

type Config struct {
    PanelURL         string   `yaml:"panel_url"`
    Username         string   `yaml:"username"`
    Password         string   `yaml:"password"`
    TelegramBotToken string   `yaml:"telegram_bot_token"`
    TelegramChatID   int64    `yaml:"telegram_chat_id"`
    SendInterval     int      `yaml:"send_interval"`
    EnableBlocked    bool     `yaml:"enable_blocked"`
    EnableRejected   bool     `yaml:"enable_rejected"`
    EnableConnected  bool     `yaml:"enable_connected"`
    IPLimit          int      `yaml:"ip_limit"`
    RestoreMinutes   int      `yaml:"restore_minutes"`
    Whitelist        []string `yaml:"whitelist"`
}


type UserDetail struct {
    Username    string `json:"username"`
    Status      string `json:"status"`
    UsedTraffic int64  `json:"used_traffic"`
    DataLimit   int64  `json:"data_limit"`
    Expire      string `json:"expire"`
    OnlineAt    string `json:"online_at"`
}

type Node struct {
    ID   int    `json:"id"`
    Name string `json:"name"`
}

type LogEvent struct {
    Timestamp string
    Username  string
    IP        string
    NodeName  string
    EventType string
}

type ActiveIP struct {
    Username string
    IP       string
    NodeName string
    LastSeen time.Time
}

type Stats struct {
    BlockedToday   int
    RejectedToday  int
    ConnectedToday int
    LastReset      time.Time
}

type ViolationRecord struct {
    Username     string
    ViolationCount int
    LastViolation time.Time
    DisabledAt   *time.Time
}

var (
    violations      map[string]*ViolationRecord
    violationsMutex sync.Mutex
)

var (
    config      Config
    bot         *tgbotapi.BotAPI
    authToken   string
    httpClient  *http.Client
    logPattern  *regexp.Regexp
    
    blockedEvents   []LogEvent
    rejectedEvents  []LogEvent
    connectedEvents []LogEvent
    eventMutex      sync.Mutex
    
    activeIPs      map[string]*ActiveIP
    activeIPsMutex sync.RWMutex
    
    dailyStats Stats
    statsMutex sync.Mutex
)

func main() {
    log.SetFlags(log.LstdFlags)
    log.Println("ğŸš€ PasarGuard Monitor Starting...")

    if err := loadConfig("config.yaml"); err != nil {
        log.Fatalf("âŒ Failed to load config: %v", err)
    }

    httpClient = &http.Client{
        Transport: &http.Transport{
            TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
        },
        Timeout: 0,
    }
    
    logPattern = regexp.MustCompile(`^data: ([^ ]+\s+[^ ]+) from ([\d.]+):\d+ (\w+) .*email: (.+)$`)
    activeIPs = make(map[string]*ActiveIP)
    violations = make(map[string]*ViolationRecord)
    dailyStats = Stats{LastReset: time.Now()}

    var err error
    bot, err = tgbotapi.NewBotAPI(config.TelegramBotToken)
    if err != nil {
        log.Fatalf("âŒ Failed to connect to Telegram: %v", err)
    }
    log.Printf("âœ… Connected to Telegram as @%s", bot.Self.UserName)

    if err := login(); err != nil {
        log.Fatalf("âŒ Login failed: %v", err)
    }
    log.Println("âœ… Logged in successfully")

    nodes, err := getNodes()
    if err != nil {
        log.Fatalf("âŒ Failed to get nodes: %v", err)
    }
    log.Printf("âœ… Found %d nodes", len(nodes))

    sendMessage("ğŸŸ¢ Ø³Ø±ÙˆÛŒØ³ Ù…Ø§Ù†ÛŒØªÙˆØ± Ù¾Ø§Ø³Ø§Ø±Ú¯Ø§Ø¯ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø´Ø¯\n\nØ¯Ø³ØªÙˆØ±Ø§Øª:\n/stats - Ø¢Ù…Ø§Ø±\n/user <username> - Ø¬Ø³ØªØ¬Ùˆ\n/help - Ø±Ø§Ù‡Ù†Ù…Ø§")

    go handleTelegramCommands()
    go sendPeriodicUpdates()
    go cleanupOldIPs()
    go sendDailyStats()
   go sendActiveUsersReport()
   go autoDisableViolators()
   go autoRestoreUsers()

    var wg sync.WaitGroup
    for _, node := range nodes {
        wg.Add(1)
        go func(n Node) {
            defer wg.Done()
            streamNodeLogs(n)
        }(node)
    }

    wg.Wait()
}

func loadConfig(filename string) error {
    data, err := ioutil.ReadFile(filename)
    if err != nil {
        return err
    }
    return yaml.Unmarshal(data, &config)
}

func login() error {
    loginData := fmt.Sprintf("username=%s&password=%s", config.Username, config.Password)
    resp, err := httpClient.Post(
        config.PanelURL+"/api/admin/token",
        "application/x-www-form-urlencoded",
        bytes.NewBuffer([]byte(loginData)),
    )
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    var result map[string]interface{}
    if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
        return err
    }

    authToken = result["access_token"].(string)
    return nil
}

func getNodes() ([]Node, error) {
    req, _ := http.NewRequest("GET", config.PanelURL+"/api/nodes", nil)
    req.Header.Set("Authorization", "Bearer "+authToken)

    resp, err := httpClient.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    var result struct {
        Nodes []Node `json:"nodes"`
    }
    if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
        return nil, err
    }

    return result.Nodes, nil
}

func streamNodeLogs(node Node) {
    log.Printf("ğŸ“‚ Monitoring node: %s (ID: %d)", node.Name, node.ID)

    for {
        func() {
            req, _ := http.NewRequest("GET", fmt.Sprintf("%s/api/node/%d/logs", config.PanelURL, node.ID), nil)
            req.Header.Set("Authorization", "Bearer "+authToken)

            resp, err := httpClient.Do(req)
            if err != nil {
                log.Printf("âŒ Error connecting to %s: %v. Retrying in 10s...", node.Name, err)
                time.Sleep(10 * time.Second)
                return
            }
            defer resp.Body.Close()

            scanner := bufio.NewScanner(resp.Body)
            for scanner.Scan() {
                line := scanner.Text()
                if line != "" {
                    processLogLine(line, node.Name)
                }
            }

            if err := scanner.Err(); err != nil {
                log.Printf("âŒ Error streaming logs for %s: %v. Retrying in 10s...", node.Name, err)
                time.Sleep(10 * time.Second)
            }
        }()
    }
}

func processLogLine(line, nodeName string) {
    match := logPattern.FindStringSubmatch(line)
    if len(match) < 5 {
        return
    }

    timestamp := match[1]
    ip := match[2]
    eventType := match[3]
    rawEmail := match[4]
    
    username := rawEmail
    if strings.Contains(rawEmail, ".") {
        parts := strings.Split(rawEmail, ".")
        if len(parts) > 1 {
            username = parts[1]
        }
    }

    event := LogEvent{
        Timestamp: timestamp,
        Username:  username,
        IP:        ip,
        NodeName:  nodeName,
        EventType: eventType,
    }

    if eventType == "accepted" {
        trackActiveIP(username, ip, nodeName)
    }

    eventMutex.Lock()
    defer eventMutex.Unlock()

    if eventType == "rejected" && config.EnableRejected {
        rejectedEvents = append(rejectedEvents, event)
        updateStats("rejected")
    } else if eventType == "accepted" && config.EnableConnected {
        connectedEvents = append(connectedEvents, event)
        updateStats("connected")
    } else if eventType != "accepted" && eventType != "rejected" && config.EnableBlocked {
        blockedEvents = append(blockedEvents, event)
        updateStats("blocked")
    }
}

func trackActiveIP(username, ip, nodeName string) {
    activeIPsMutex.Lock()
    defer activeIPsMutex.Unlock()
    
    key := username + "-" + ip
    activeIPs[key] = &ActiveIP{
        Username: username,
        IP:       ip,
        NodeName: nodeName,
        LastSeen: time.Now(),
    }
}

func cleanupOldIPs() {
    ticker := time.NewTicker(30 * time.Second)
    for range ticker.C {
        activeIPsMutex.Lock()
        now := time.Now()
        for key, active := range activeIPs {
            if now.Sub(active.LastSeen) > 60*time.Second {
                delete(activeIPs, key)
            }
        }
        activeIPsMutex.Unlock()
    }
}

func updateStats(eventType string) {
    statsMutex.Lock()
    defer statsMutex.Unlock()
    
    if time.Since(dailyStats.LastReset) > 24*time.Hour {
        dailyStats = Stats{LastReset: time.Now()}
    }
    
    switch eventType {
    case "blocked":
        dailyStats.BlockedToday++
    case "rejected":
        dailyStats.RejectedToday++
    case "connected":
        dailyStats.ConnectedToday++
    }
}

func sendPeriodicUpdates() {
    ticker := time.NewTicker(time.Duration(config.SendInterval) * time.Second)
    for range ticker.C {
        sendTelegramUpdates()
    }
}

func sendTelegramUpdates() {
    eventMutex.Lock()
    blocked := blockedEvents
    rejected := rejectedEvents
    connected := connectedEvents
    blockedEvents = nil
    rejectedEvents = nil
    connectedEvents = nil
    eventMutex.Unlock()

    if len(blocked) == 0 && len(rejected) == 0 && len(connected) == 0 {
        return
    }

    var message strings.Builder

    if len(blocked) > 0 {
        message.WriteString("ğŸš« Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø¨Ù„Ø§Ú© Ø´Ø¯Ù‡:\n")
        seen := make(map[string]bool)
        for _, event := range blocked {
            key := event.Username + "-" + event.IP
            if !seen[key] {
                seen[key] = true
                
                details := getUserDetails(event.Username)
                message.WriteString(fmt.Sprintf("Ù†ÙˆØ¯ %s:\n", event.NodeName))
                message.WriteString(fmt.Sprintf("  â€¢ %s - IP: %s\n", event.Username, event.IP))
                if details != "" {
                    message.WriteString(fmt.Sprintf("    %s\n", details))
                }
            }
        }
        message.WriteString("\n")
    }

    if len(rejected) > 0 {
        message.WriteString("âŒ Ø§ØªØµØ§Ù„Ø§Øª Ø±Ø¯ Ø´Ø¯Ù‡:\n")
        seen := make(map[string]bool)
        for _, event := range rejected {
            key := event.Username + "-" + event.IP
            if !seen[key] {
                seen[key] = true
                message.WriteString(fmt.Sprintf("Ù†ÙˆØ¯ %s:\n", event.NodeName))
                message.WriteString(fmt.Sprintf("  â€¢ %s - IP: %s\n", event.Username, event.IP))
            }
        }
        message.WriteString("\n")
    }

    if len(connected) > 0 {
        message.WriteString("ğŸŸ¢ Ø§ØªØµØ§Ù„Ø§Øª Ø¬Ø¯ÛŒØ¯:\n")
        seen := make(map[string]bool)
        nodeGroups := make(map[string][]LogEvent)
        
        for _, event := range connected {
            key := event.Username + "-" + event.IP
            if !seen[key] {
                seen[key] = true
                nodeGroups[event.NodeName] = append(nodeGroups[event.NodeName], event)
            }
        }
        
        for nodeName, events := range nodeGroups {
            message.WriteString(fmt.Sprintf("Ù†ÙˆØ¯ %s:\n", nodeName))
            for _, event := range events {
                message.WriteString(fmt.Sprintf("  â€¢ %s - IP: %s\n", event.Username, event.IP))
            }
        }
    }

    if message.Len() > 0 {
        sendMessage(message.String())
    }
}

func getUserDetails(username string) string {
    req, _ := http.NewRequest("GET", config.PanelURL+"/api/user/"+username, nil)
    req.Header.Set("Authorization", "Bearer "+authToken)

    resp, err := httpClient.Do(req)
    if err != nil {
        return "âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª"
    }
    defer resp.Body.Close()

    var user UserDetail
    if err := json.NewDecoder(resp.Body).Decode(&user); err != nil {
        return "âš ï¸ Ø®Ø·Ø§ Ø¯Ø± parse"
    }

    var details strings.Builder
    
    statusEmoji := "âœ…"
    if user.Status != "active" {
        statusEmoji = "ğŸ”´"
    }
    details.WriteString(fmt.Sprintf("%s %s", statusEmoji, user.Status))
    
    usedGB := float64(user.UsedTraffic) / 1073741824
    limitGB := float64(user.DataLimit) / 1073741824
    percentage := (float64(user.UsedTraffic) / float64(user.DataLimit)) * 100
    details.WriteString(fmt.Sprintf(" | ğŸ“Š %.1fGB/%.0fGB (%.0f%%)", usedGB, limitGB, percentage))
    
    if user.Expire != "" {
        expireTime, err := time.Parse(time.RFC3339, user.Expire)
        if err == nil {
            daysLeft := int(time.Until(expireTime).Hours() / 24)
            if daysLeft < 0 {
                details.WriteString(" | â° Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡")
            } else {
                details.WriteString(fmt.Sprintf(" | â° %d Ø±ÙˆØ²", daysLeft))
            }
        }
    }

    return details.String()
}

func handleTelegramCommands() {
    u := tgbotapi.NewUpdate(0)
    u.Timeout = 60

    updates := bot.GetUpdatesChan(u)

    for update := range updates {
        if update.Message == nil {
            continue
        }

        if update.Message.Chat.ID != config.TelegramChatID {
            continue
        }

        command := update.Message.Command()
        args := update.Message.CommandArguments()

        switch command {
                case "start", "help":
            helpText := `ğŸ“š Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ Ø¯Ø³ØªÙˆØ±Ø§Øª:

ğŸ“Š Ù…Ø§Ù†ÛŒØªÙˆØ±ÛŒÙ†Ú¯:
/stats - Ø¢Ù…Ø§Ø± Ú©Ù„ÛŒ Ø³ÛŒØ³ØªÙ…
/user <username> - Ø¬Ø³ØªØ¬ÙˆÛŒ ÛŒÙˆØ²Ø± Ùˆ IP Ù‡Ø§ÛŒ ÙØ¹Ø§Ù„
/nodes - ÙˆØ¶Ø¹ÛŒØª Ù†ÙˆØ¯Ù‡Ø§

âš™ï¸ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù…Ø­Ø¯ÙˆØ¯ÛŒØª IP:
/settings - Ù†Ù…Ø§ÛŒØ´ ØªÙ†Ø¸ÛŒÙ…Ø§Øª ÙØ¹Ù„ÛŒ
/setlimit <Ø¹Ø¯Ø¯> - ØªØºÛŒÛŒØ± Ø­Ø¯ Ù…Ø¬Ø§Ø² IP
/setrestore <Ø¯Ù‚ÛŒÙ‚Ù‡> - Ø²Ù…Ø§Ù† Ø¨Ø§Ø²Ú¯Ø±Ø¯Ø§Ù†ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø±

ğŸ“‹ Ù…Ø¯ÛŒØ±ÛŒØª Ø§Ø³ØªØ«Ù†Ø§Ù‡Ø§:
/whitelist add <username> - Ø§ÙØ²ÙˆØ¯Ù† Ø¨Ù‡ Ù„ÛŒØ³Øª Ø³ÙÛŒØ¯
/whitelist remove <username> - Ø­Ø°Ù Ø§Ø² Ù„ÛŒØ³Øª Ø³ÙÛŒØ¯
/whitelist list - Ù†Ù…Ø§ÛŒØ´ Ù„ÛŒØ³Øª

/help - Ù†Ù…Ø§ÛŒØ´ Ø§ÛŒÙ† Ø±Ø§Ù‡Ù†Ù…Ø§`
            sendMessage(helpText)


        case "stats":
            handleStatsCommand()

        case "user":
            if args == "" {
                sendMessage("âŒ Ù„Ø·ÙØ§Ù‹ Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:\n/user username")
            } else {
                handleUserCommand(args)
            }

        case "nodes":
            handleNodesCommand()
        case "setlimit":
            if args == "" {
                sendMessage("âŒ Ù…Ø«Ø§Ù„: /setlimit 5")
            } else {
                handleSetLimit(args)
            }

        case "setrestore":
            if args == "" {
                sendMessage("âŒ Ù…Ø«Ø§Ù„: /setrestore 90")
            } else {
                handleSetRestore(args)
            }

        case "whitelist":
            handleWhitelist(args)

        case "settings":
            handleSettingsCommand()

        }
    }
}

func handleStatsCommand() {
    statsMutex.Lock()
    stats := dailyStats
    statsMutex.Unlock()

    activeIPsMutex.RLock()
    activeCount := len(activeIPs)
    activeIPsMutex.RUnlock()

    message := fmt.Sprintf(`ğŸ“Š Ø¢Ù…Ø§Ø± Ø³ÛŒØ³ØªÙ…

ğŸš« Ø¨Ù„Ø§Ú© Ø´Ø¯Ù‡ Ø§Ù…Ø±ÙˆØ²: %d
âŒ Ø±Ø¯ Ø´Ø¯Ù‡ Ø§Ù…Ø±ÙˆØ²: %d
ğŸŸ¢ Ø§ØªØµØ§Ù„ Ø¬Ø¯ÛŒØ¯ Ø§Ù…Ø±ÙˆØ²: %d
ğŸ“¡ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† ÙØ¹Ø§Ù„ Ø§Ù„Ø§Ù†: %d

ğŸ• Ø³Ø§Ø¹Øª: %s`,
        stats.BlockedToday,
        stats.RejectedToday,
        stats.ConnectedToday,
        activeCount,
        time.Now().Format("15:04:05"),
    )

    sendMessage(message)
}

func handleUserCommand(username string) {
    details := getUserDetails(username)
    
    activeIPsMutex.RLock()
    var userIPs []string
    for _, active := range activeIPs {
        if active.Username == username {
            userIPs = append(userIPs, fmt.Sprintf("  â€¢ IP: %s | Ù†ÙˆØ¯: %s | %s Ù¾ÛŒØ´",
                active.IP,
                active.NodeName,
                time.Since(active.LastSeen).Round(time.Second),
            ))
        }
    }
    activeIPsMutex.RUnlock()

    var message strings.Builder
    message.WriteString(fmt.Sprintf("ğŸ‘¤ Ú©Ø§Ø±Ø¨Ø±: %s\n\n", username))
    
    if details != "" {
        message.WriteString(details + "\n\n")
    }
    
    if len(userIPs) > 0 {
        message.WriteString(fmt.Sprintf("ğŸ“ IP Ù‡Ø§ÛŒ ÙØ¹Ø§Ù„ (%d):\n", len(userIPs)))
        for _, ip := range userIPs {
            message.WriteString(ip + "\n")
        }
    } else {
        message.WriteString("âš ï¸ Ù‡ÛŒÚ† IP ÙØ¹Ø§Ù„ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯")
    }

    sendMessage(message.String())
}

func handleNodesCommand() {
    nodes, err := getNodes()
    if err != nil {
        sendMessage("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù„ÛŒØ³Øª Ù†ÙˆØ¯Ù‡Ø§")
        return
    }

    var message strings.Builder
    message.WriteString(fmt.Sprintf("ğŸ“¡ Ù„ÛŒØ³Øª Ù†ÙˆØ¯Ù‡Ø§ (%d):\n\n", len(nodes)))
    
    for _, node := range nodes {
        message.WriteString(fmt.Sprintf("â€¢ %s (ID: %d)\n", node.Name, node.ID))
    }

    sendMessage(message.String())
}
func sendActiveUsersReport() {
    log.Println("ğŸ” DEBUG: sendActiveUsersReport goroutine started")
    ticker := time.NewTicker(5 * time.Minute)
    for range ticker.C {
        log.Println("ğŸ” DEBUG: Generating active users report...")
        activeIPsMutex.RLock()
        
        userIPs := make(map[string][]string)
        for _, active := range activeIPs {
            userIPs[active.Username] = append(userIPs[active.Username], 
                fmt.Sprintf("%s (Ù†ÙˆØ¯: %s)", active.IP, active.NodeName))
        }
        totalUsers := len(userIPs)
        activeIPsMutex.RUnlock()
        
        log.Printf("ğŸ” DEBUG: Found %d active users", totalUsers)
        
        if len(userIPs) == 0 {
            continue
        }

        var message strings.Builder
        message.WriteString(fmt.Sprintf("ğŸ“Š Ú¯Ø²Ø§Ø±Ø´ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† ÙØ¹Ø§Ù„ - %s\n\n", 
            time.Now().Format("15:04")))

        multiIPUsers := 0
        for username, ips := range userIPs {
            if len(ips) > 1 {
                multiIPUsers++
                message.WriteString(fmt.Sprintf("ğŸ‘¤ %s (%d IP):\n", username, len(ips)))
                for _, ip := range ips {
                    message.WriteString(fmt.Sprintf("  â€¢ %s\n", ip))
                }
                message.WriteString("\n")
            }
        }

        if multiIPUsers == 0 {
            message.WriteString("âœ… Ù‡Ù…Ù‡ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† ØªÚ© IP Ù‡Ø³ØªÙ†Ø¯")
        } else {
            message.WriteString(fmt.Sprintf("âš ï¸ ØªØ¹Ø¯Ø§Ø¯ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ú†Ù†Ø¯ IP: %d", multiIPUsers))
        }

        sendMessage(message.String())
    }
}

func autoDisableViolators() {
    ticker := time.NewTicker(5 * time.Minute)
    for range ticker.C {
        activeIPsMutex.RLock()
        userIPCount := make(map[string]int)
        for _, active := range activeIPs {
            userIPCount[active.Username]++
        }
        activeIPsMutex.RUnlock()
        
        violationsMutex.Lock()
        for username, count := range userIPCount {
            // Ú†Ú© Ú©Ù† Ø¯Ø± whitelist Ù‡Ø³Øª ÛŒØ§ Ù†Ù‡
            if isWhitelisted(username) {
                continue
            }
            
            if count > config.IPLimit {
                if violations[username] == nil {
                    violations[username] = &ViolationRecord{
                        Username: username,
                    }
                }
                
                rec := violations[username]
                
                // Ø§Ú¯Ù‡ Ù‚Ø¨Ù„Ø§Ù‹ disable Ø´Ø¯Ù‡ØŒ skip
                if rec.DisabledAt != nil {
                    continue
                }
                
                // Ø§ÙØ²Ø§ÛŒØ´ ØªØ¹Ø¯Ø§Ø¯ ØªØ®Ù„Ù
                if time.Since(rec.LastViolation) > 10*time.Minute {
                    rec.ViolationCount = 1
                } else {
                    rec.ViolationCount++
                }
                rec.LastViolation = time.Now()
                
                log.Printf("âš ï¸ %s has %d IPs (violation %d/3)", username, count, rec.ViolationCount)
                
                // Ø¨Ø¹Ø¯ Ø§Ø² 3 Ø¨Ø§Ø±ØŒ disable Ú©Ù†
                if rec.ViolationCount >= 3 {
                    if disableUser(username) {
                        now := time.Now()
                        rec.DisabledAt = &now
                        msg := fmt.Sprintf("ğŸš« Ú©Ø§Ø±Ø¨Ø± %s Ø¨Ù‡ Ø¯Ù„ÛŒÙ„ %d IP ÙØ¹Ø§Ù„ ØºÛŒØ±ÙØ¹Ø§Ù„ Ø´Ø¯\nâ° Ø±ÙˆØ´Ù† Ù…ÛŒâ€ŒØ´ÙˆØ¯: %d Ø¯Ù‚ÛŒÙ‚Ù‡ Ø¯ÛŒÚ¯Ø±",
                            username, count, config.RestoreMinutes)
                        sendMessage(msg)
                        log.Printf("ğŸš« Disabled user: %s (%d IPs)", username, count)
                    }
                }
            }
        }
        violationsMutex.Unlock()
    }
}

func autoRestoreUsers() {
    ticker := time.NewTicker(1 * time.Minute)
    for range ticker.C {
        violationsMutex.Lock()
        for username, rec := range violations {
            if rec.DisabledAt != nil {
                if time.Since(*rec.DisabledAt) >= time.Duration(config.RestoreMinutes)*time.Minute {
                    if enableUser(username) {
                        msg := fmt.Sprintf("âœ… Ú©Ø§Ø±Ø¨Ø± %s Ø¯ÙˆØ¨Ø§Ø±Ù‡ ÙØ¹Ø§Ù„ Ø´Ø¯", username)
                        sendMessage(msg)
                        log.Printf("âœ… Re-enabled user: %s", username)
                        delete(violations, username)
                    }
                }
            }
        }
        violationsMutex.Unlock()
    }
}

func isWhitelisted(username string) bool {
    for _, w := range config.Whitelist {
        if w == username {
            return true
        }
    }
    return false
}

func disableUser(username string) bool {
    payload := map[string]interface{}{"status": "disabled"}
    return updateUserStatus(username, payload)
}

func enableUser(username string) bool {
    payload := map[string]interface{}{"status": "active"}
    return updateUserStatus(username, payload)
}

func updateUserStatus(username string, payload map[string]interface{}) bool {
    jsonData, _ := json.Marshal(payload)
    
    req, _ := http.NewRequest("PUT", config.PanelURL+"/api/user/"+username, bytes.NewBuffer(jsonData))
    req.Header.Set("Authorization", "Bearer "+authToken)
    req.Header.Set("Content-Type", "application/json")
    
    resp, err := httpClient.Do(req)
    if err != nil {
        log.Printf("âŒ Failed to update %s: %v", username, err)
        return false
    }
    defer resp.Body.Close()
    
    return resp.StatusCode == 200
}


func sendDailyStats() {
    now := time.Now()
    midnight := time.Date(now.Year(), now.Month(), now.Day()+1, 0, 0, 0, 0, now.Location())
    time.Sleep(time.Until(midnight))

    ticker := time.NewTicker(24 * time.Hour)
    for range ticker.C {
        statsMutex.Lock()
        stats := dailyStats
        dailyStats = Stats{LastReset: time.Now()}
        statsMutex.Unlock()

        message := fmt.Sprintf(`ğŸ“Š Ú¯Ø²Ø§Ø±Ø´ Ø±ÙˆØ²Ø§Ù†Ù‡

ğŸš« Ø¨Ù„Ø§Ú© Ø´Ø¯Ù‡: %d
âŒ Ø±Ø¯ Ø´Ø¯Ù‡: %d  
ğŸŸ¢ Ø§ØªØµØ§Ù„Ø§Øª: %d

ğŸ“… %s`,
            stats.BlockedToday,
            stats.RejectedToday,
            stats.ConnectedToday,
            time.Now().Format("2006-01-02"),
        )

        sendMessage(message)
    }
}

func handleSetLimit(args string) {
    var limit int
    fmt.Sscanf(args, "%d", &limit)
    if limit < 1 || limit > 20 {
        sendMessage("âŒ Ø¹Ø¯Ø¯ Ø¨Ø§ÛŒØ¯ Ø¨ÛŒÙ† 1 ØªØ§ 20 Ø¨Ø§Ø´Ø¯")
        return
    }
    config.IPLimit = limit
    saveConfig()
    sendMessage(fmt.Sprintf("âœ… Ø­Ø¯ IP Ø¨Ù‡ %d ØªØºÛŒÛŒØ± Ú©Ø±Ø¯", limit))
}

func handleSetRestore(args string) {
    var minutes int
    fmt.Sscanf(args, "%d", &minutes)
    if minutes < 10 || minutes > 1440 {
        sendMessage("âŒ Ø²Ù…Ø§Ù† Ø¨Ø§ÛŒØ¯ Ø¨ÛŒÙ† 10 ØªØ§ 1440 Ø¯Ù‚ÛŒÙ‚Ù‡ Ø¨Ø§Ø´Ø¯")
        return
    }
    config.RestoreMinutes = minutes
    saveConfig()
    sendMessage(fmt.Sprintf("âœ… Ø²Ù…Ø§Ù† Ø¨Ø§Ø²Ú¯Ø±Ø¯Ø§Ù†ÛŒ Ø¨Ù‡ %d Ø¯Ù‚ÛŒÙ‚Ù‡ ØªØºÛŒÛŒØ± Ú©Ø±Ø¯", minutes))
}

func handleWhitelist(args string) {
    parts := strings.Fields(args)
    if len(parts) == 0 {
        sendMessage("âŒ Ø¯Ø³ØªÙˆØ± Ù†Ø§Ù…Ø¹ØªØ¨Ø±\n\n/whitelist add username\n/whitelist remove username\n/whitelist list")
        return
    }
    
    action := parts[0]
    
    switch action {
    case "add":
        if len(parts) < 2 {
            sendMessage("âŒ Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯")
            return
        }
        username := parts[1]
        config.Whitelist = append(config.Whitelist, username)
        saveConfig()
        sendMessage(fmt.Sprintf("âœ… %s Ø¨Ù‡ Ù„ÛŒØ³Øª Ø§Ø³ØªØ«Ù†Ø§ Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯", username))
        
    case "remove":
        if len(parts) < 2 {
            sendMessage("âŒ Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯")
            return
        }
        username := parts[1]
        newList := []string{}
        for _, w := range config.Whitelist {
            if w != username {
                newList = append(newList, w)
            }
        }
        config.Whitelist = newList
        saveConfig()
        sendMessage(fmt.Sprintf("âœ… %s Ø§Ø² Ù„ÛŒØ³Øª Ø§Ø³ØªØ«Ù†Ø§ Ø­Ø°Ù Ø´Ø¯", username))
        
    case "list":
        if len(config.Whitelist) == 0 {
            sendMessage("ğŸ“‹ Ù„ÛŒØ³Øª Ø§Ø³ØªØ«Ù†Ø§ Ø®Ø§Ù„ÛŒ Ø§Ø³Øª")
            return
        }
        var msg strings.Builder
        msg.WriteString("ğŸ“‹ Ù„ÛŒØ³Øª Ø§Ø³ØªØ«Ù†Ø§:\n\n")
        for _, w := range config.Whitelist {
            msg.WriteString(fmt.Sprintf("â€¢ %s\n", w))
        }
        sendMessage(msg.String())
        
    default:
        sendMessage("âŒ Ø¯Ø³ØªÙˆØ± Ù†Ø§Ù…Ø¹ØªØ¨Ø±")
    }
}

func handleSettingsCommand() {
    msg := fmt.Sprintf(`âš™ï¸ ØªÙ†Ø¸ÛŒÙ…Ø§Øª ÙØ¹Ù„ÛŒ:

ğŸ”¢ Ø­Ø¯ IP: %d
â° Ø²Ù…Ø§Ù† Ø¨Ø§Ø²Ú¯Ø±Ø¯Ø§Ù†ÛŒ: %d Ø¯Ù‚ÛŒÙ‚Ù‡
ğŸ“‹ ØªØ¹Ø¯Ø§Ø¯ Ø§Ø³ØªØ«Ù†Ø§: %d

Ø¯Ø³ØªÙˆØ±Ø§Øª:
/setlimit <Ø¹Ø¯Ø¯> - ØªØºÛŒÛŒØ± Ø­Ø¯ IP
/setrestore <Ø¯Ù‚ÛŒÙ‚Ù‡> - ØªØºÛŒÛŒØ± Ø²Ù…Ø§Ù† Ø¨Ø§Ø²Ú¯Ø±Ø¯Ø§Ù†ÛŒ
/whitelist add <username> - Ø§ÙØ²ÙˆØ¯Ù† Ø§Ø³ØªØ«Ù†Ø§
/whitelist remove <username> - Ø­Ø°Ù Ø§Ø³ØªØ«Ù†Ø§
/whitelist list - Ù†Ù…Ø§ÛŒØ´ Ù„ÛŒØ³Øª`,
        config.IPLimit,
        config.RestoreMinutes,
        len(config.Whitelist),
    )
    sendMessage(msg)
}

func saveConfig() {
    data, _ := yaml.Marshal(&config)
    ioutil.WriteFile("config.yaml", data, 0644)
}

func sendMessage(text string) {
    // Ø§Ú¯Ù‡ Ù¾ÛŒØ§Ù… Ø®ÛŒÙ„ÛŒ Ø·ÙˆÙ„Ø§Ù†ÛŒÙ‡ØŒ ØªÚ©Ù‡ ØªÚ©Ù‡ Ú©Ù†
    maxLength := 4000
    if len(text) <= maxLength {
        msg := tgbotapi.NewMessage(config.TelegramChatID, text)
        if _, err := bot.Send(msg); err != nil {
            log.Printf("âŒ Failed to send message: %v", err)
        }
        return
    }
    
    // ØªÚ©Ù‡ ØªÚ©Ù‡ Ú©Ù†
    parts := []string{}
    for len(text) > 0 {
        if len(text) <= maxLength {
            parts = append(parts, text)
            break
        }
        
        // Ù¾ÛŒØ¯Ø§ Ú©Ù† Ø¢Ø®Ø±ÛŒÙ† \n Ù‚Ø¨Ù„ Ø§Ø² maxLength
        cutPoint := maxLength
        for i := maxLength - 1; i > 0; i-- {
            if text[i] == '\n' {
                cutPoint = i
                break
            }
        }
        
        parts = append(parts, text[:cutPoint])
        text = text[cutPoint:]
    }
    
    // ÙØ±Ø³ØªØ§Ø¯Ù† ØªÚ©Ù‡ Ù‡Ø§
    for i, part := range parts {
        if i > 0 {
            time.Sleep(1 * time.Second) // Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² rate limit
        }
        msg := tgbotapi.NewMessage(config.TelegramChatID, part)
        if _, err := bot.Send(msg); err != nil {
            log.Printf("âŒ Failed to send message part %d: %v", i+1, err)
        }
    }
}


